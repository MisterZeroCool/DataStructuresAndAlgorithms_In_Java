Очереди
    Структура данных, называемая в информатике очередью, напоминает стек, но
в очереди первым извлекается элемент, вставленный первым (FIFO, First-In-FirstOut),
тогда как в стеке, как мы видели, первым извлекается элемент, вставленный
последним (LIFO). Она работает по тому же принципу, что и очередь в кино: человек,
первым вставшим в очередь, первым доберется до кассы и купит билет. Тот, кто
встанет в очередь последним, последним купит билет (или не купит, если билеты
будут распроданы).
    В операционной системе вашего компьютера (и в сети) трудятся различные
очереди, незаметно выполняющие свои обязанности. В очереди печати задания
ждут освобождения принтера. Данные, вводимые с клавиатуры, тоже сохраняются
в очереди. Если вы работаете в текстовом редакторе, а компьютер на короткое
время отвлекся на выполнение другой операции, нажатия клавиш не будут потеряны;
они ожидают в очереди, пока у редактора не появится свободное время
для их получения. Очередь обеспечивает хранение нажатий клавиш в исходной
последовательности до момента обработки.

    Две основные операции с очередью — ВСТАВКА элемента в конец очереди и ИЗВЛЕЧЕНИЕ
элемента с начала очереди.

    При вставке нового элемента в приложении Queue Workshop маркер Front смещается вверх,
в направлении более высоких индексов. При удалении элемента маркер
Rear тоже смещается вверх. Попробуйте выполнить эти операции в приложении
и убедитесь в том, что это действительно так. На первый взгляд такое поведение
выглядит противоестественно — ведь когда вы стоите в очереди в кино, при выходе
очередного человека все остальные сдвигаются к началу очереди. Конечно, при
удалении можно было бы перемещать все элементы в очереди, но копирование
снизило бы эффективность операции. Вместо этого мы оставляем все элементы на
своих местах, а смещаем начало и конец очереди.
    Проблема в том, что довольно скоро конец очереди достигнет границы массива
(элемент с наибольшим индексом). Даже если в начале массива имеются пустые
ячейки, из которых были удалены элементы, вставить новый элемент не удастся,
потому что маркеру Rear дальше двигаться некуда. Или все-таки…?

Циклический перенос
    Для решения проблемы со вставкой новых элементов в очередь, в которой имеются
свободные ячейки, маркеры Front и Rear при достижении границы массива пере-
мещается к его началу. Такая структура данных называется циклической очередью
(также иногда встречается термин кольцевой буфер).

Реализация
    Программа queue.java реализует очередь в виде класса Queue. Класс содержит типи-
чные методы insert(), remove(), peek(), isFull(), isEmpty() и size().
    Программа main() создает очередь из пяти ячеек, вставляет в нее четыре элемента,
затем удаляет три элемента и вставляет еще четыре. При шестой вставке
происходит циклический перенос. Затем программа извлекает и выводит значения
всех элементов. Результат выглядит так:
40 50 60 70 80

Реализация без счетчика элементов
    Включение поля nItems в класс Queue слегка снижает эффективность методов
insert() и remove(), которым приходится соответственно увеличивать и уменьшать
эту переменную. На первый взгляд потери невелики, но при очень большом количе-
стве операций вставки и удаления они могут повлиять на производительность.
    По этой причине некоторые реализации очередей обходятся без счетчика элементов,
а для проверки заполненности/отсутствия элементов и количества элементов в очере-
ди используются значения полей front и rear. Однако методы isEmpty(),
isFull() и size() становятся неожиданно сложными, потому что последовательность эле-
ментов, как мы уже видели, может быть как непрерывной, так и несвязной.
    Также может возникнуть одна странная проблема: при заполненной очереди
указатели front и rear могут занимать точно такие же позиции, как и при пустой
очереди. Очередь выглядит заполненной и пустой одновременно. Для решения этой
проблемы создается массив с количеством ячеек, на единицу большим максимального
количества элементов, которые в нем будут размещаться.

Эффективность очередей
Вставка и извлечение элементов очереди, как и элементов стека, выполняются за
время O(1).

Итоги
- Стеки, очереди и приоритетные очереди обычно используются для упрощения
некоторых операций из области программирования.
- В этих структурах данных доступен только один элемент.
- В стеке доступен элемент, который был вставлен последним.
- Основные операции со стеком — вставка (занесение) элемента на вершину стека
и извлечение элемента, находящегося на вершине.
- В очереди доступен элемент, который был вставлен первым.
- Основные операции с очередью — вставка элемента в конец очереди и извлече-
ние элемента в начале очереди.
- Очередь может быть реализована в форме циклической очереди (на базе массива),
в которой осуществляется циклический переход индексов от конца массива
к началу.
- В приоритетной очереди доступен элемент с наименьшим (или иногда с наиболь-
шим) значением ключа.
- Основные операции с приоритетной очередью — вставка элемента в порядке
сортировки и удаление элемента с наименьшим значением ключа.
- Эти структуры данных реализуются на базе массивов или других структур (например, связанных списков)



