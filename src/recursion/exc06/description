Сортировка слиянием
    Алгоритм сортировки слиянием завершает наше знакомство с рекурсией. Этот
алгоритм сортировки намного эффективнее алгоритмов чем «Простая сортировка» —
по крайней мере в отношении скорости. Если пузырьковая сортировка, сортировка
методом вставки и сортировка методом выбора выполняются за время O(N 2),
то сортировка слиянием выполняется за время O(N × logN). Например, если N
(количество сортируемых элементов) равно 10 000, то значение N 2 будет равно
100 000 000, а N × logN — всего 40 000. Если сортировка слиянием для такого
количества элементов займет 40 секунд, то сортировка методом вставок потребует
около 28 часов. Кроме того, сортировка слиянием относительно легко реализуется.
На концептуальном уровне она проще алгоритмов быстрой сортировки и сортировки
Шелла.
    Недостаток сортировки слиянием заключается в том, что она требует выделения в
памяти дополнительного массива с размером, равным размеру сортируемого
массива. Если исходный массив с трудом помещается в памяти, то сортировка
слиянием вам не подойдет, но при наличии достаточного свободного пространства
этот алгоритм весьма эффективен.

Слияние двух отсортированных массивов
    Центральное место в алгоритме сортировки слиянием занимает слияние двух предва-
рительно отсортированных массивов. В результате слияния двух сортированных
массивов A и B создается третий массив C, который содержит все элементы A и B,
также расположенные в порядке сортировки.
Представьте, что у вас имеются два предварительно отсортированных массива
(причем необязательно одинакового размера). Допустим, массив A содержит 4 элемента,
а массив B — 6. Массивы объединяются посредством слияния в массив C, изначально
состоящий из 10 пустых ячеек.

    Метод main() создает массивы arrayA, arrayB и arrayC. Затем вызывается метод
merge(), осуществляющий слияние arrayA и arrayB в arrayC, и программа выводит
полученное содержимое arrayC. Результат выполнения:
1 7 12 14 23 54 62 88 91 118
    Метод merge() содержит три цикла while. Первый цикл перебирает массивы
arrayA и arrayB, сравнивает элементы и копирует меньший из них в arrayC.
    Второй цикл используется в ситуации, в которой из массива arrayB уже были
извлечены все элементы, а в массиве arrayA элементы все еще остаются (именно
это происходит в нашем примере, где в arrayA оставались элементы 81 и 95). Цикл
просто копирует оставшиеся элементы из arrayA в arrayC.
    Третий цикл решает аналогичную задачу, когда все элементы были извлечены из
массива arrayA, а массив arrayB еще не пуст; оставшиеся элементы копируются в arrayC.

    Идея сортировки слиянием заключается в том, чтобы разделить массив пополам,
отсортировать каждую половину, а затем воспользоваться методом merge() для
слияния двух половин в один отсортированный массив. Как отсортировать каждую
половину? Глава посвящена рекурсии, поэтому, вероятно, ответ вам уже известен:
половина делится на две четверти, каждая четверть сортируется по отдельности,
после чего две четверти объединяются в отсортированную половину.
    Аналогичным образом каждая пара 8-х частей сливается в отсортированную
четверть и т. д. Массив делится снова и снова, пока не будет получен подмассив из
единственного элемента. Это базовое ограничение; предполагается, что массив из
одного элемента уже отсортирован.
    Мы видели, что в общем случае каждый вызов рекурсивного метода приводит
к уменьшению некоторого параметра, а при каждом возвращении из метода этот
параметр снова увеличивается. В mergeSort() при каждом рекурсивном вызове диа-
пазон делится надвое, а при каждом возвращении — две половины объединяются
в один больший диапазон.
    Когда метод mergeSort() возвращает управление после обнаружения двух массивов,
содержащих по одному элементу, он объединяет их в отсортированный массив
из двух элементов. Далее каждая пара полученных 2-элементных массивов объе-
диняется в массив из 4-х элементов. Процесс продолжается с массивами постоянно
увеличивающихся размеров до тех пор, пока весь массив не будет отсортирован.